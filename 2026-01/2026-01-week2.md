2026/01/13

Q1: How did you design the architecture when separating OCR from the client app?

S
When I first built the Wakarumade app, I implemented OCR directly inside the main client app.
However, it caused frequent crashes and unstable behavior.

A
I separated the OCR logic into an independent server service and let the app communicate with it via API.

R
After the separation, the app became stable and consistent, which was critical for children users.  

Q2: Describe a time you had to redesign your system because the original architecture could not scale.

S
When I built the accounting app, I initially designed the 'Page 1 of the Final Tax Return Form' as a spreadsheet format because the app used spreadsheets as a database.

A
However, this structure was not flexible enough for users to understand which numbers they should enter and what they needed to pay attention to.
So I redesigned the system to render the form in HTML inside the app.

R
As a result, the user experience improved significantly and users could understand the form much more easily.

Q3: Tell me about a system you built that failed because of architectural decisions. What did you change?

S
When I remade the Wakarumade app from web to native, OCR selection became very complicated.
I first tried to use Tesseract, but it was too heavy and caused the Render server to go down.

A
I then attempted to partially introduce Swift and use Apple Vision OCR, but this also failed because it required rewriting the entire app in Swift.

R
As a compromise, I switched to Google Vision OCR, which allowed the system to remain stable without fully changing the native architecture.  

Q4:How did you decide where to place business logic: client or server?

S

When building Wakarumade, I needed to decide where to place heavy OCR processing and core learning logic.

A

I initially placed OCR using Tesseract on the server, but it caused frequent downtime because OCR is CPU-intensive and unpredictable in load.
After failing to integrate Apple Vision OCR due to platform constraints, I re-evaluated the responsibility boundary.

I moved OCR execution to the server behind a controlled API using Google Vision, while keeping all learning UX logic, hint generation, and user interaction flows on the client.

The decision criteria were:

Security: API keys and OCR rules must never live on the client.

Stability: heavy processing must be isolated from UI to avoid cascading failures.

Maintainability: UX changes are frequent, OCR rules are not.

R

As a result, the system became stable under load, OCR failures were contained at the API layer, and I was able to iterate UX independently without touching the backend.  

Q5:Explain a trade-off you made between simplicity and flexibility in system design.  

S

When building the accounting app, I initially considered implementing Page 1 of the Japanese income tax return directly as a spreadsheet because the app already used spreadsheets as its database.

A

However, I realized that spreadsheets tightly couple UI structure and data schema.
This made it hard to:

support partial input,

add contextual annotations,

and change layout without breaking stored data.

Since the purpose of the app was not to recreate the tax form itself but to assist users in filling it out, I separated concerns:

I kept structured data in spreadsheets as the backend store.

I rebuilt the tax form UI in HTML, where layout, validation, and annotations could evolve independently from the data model.

R

This allowed me to add guidance, dynamic validation, and explanatory notes without touching the underlying data schema, making the app easier to extend when tax rules or UI requirements change.  

Q6:Describe a time you had to replace a core component (API, service, or module). How did you migrate?


S

When migrating the Wakarumade app from a web app to a native app, the existing OCR implementation that relied on Next.js APIs could no longer be used.

A

I decided to extract the OCR processing into a standalone server module instead of trying to force the same architecture into the native environment.
This allowed the native app to remain lightweight while the heavy OCR processing ran in an isolated backend service that could be scaled and debugged independently.

R

As a result, I gained a clear understanding of the architectural differences between web and native applications and established a reusable server-side OCR service that can support both platforms without coupling to any specific frontend framework.  

Q7:How did you design for failure or instability in external APIs?  

S

While developing the Track to Inventory app, the Shopify inventory sync (add/update) API behaved inconsistently, causing unexpected failures during integration and review by Shopify’s app team.

A

Instead of treating the issues as one-off bugs, I released the app in a testable state and worked directly with the Shopify review process, repeatedly validating edge cases, error responses, and undocumented API behaviors. I refined the request flow and implemented defensive checks based on the feedback from Shopify staff.

R

Through this iterative testing with the platform owner, the inventory sync became stable and reliable, and I learned how to harden integrations against unstable third-party APIs rather than assuming that external services behave as documented.  

Q8:Tell me about a time you reduced system complexity. What did you remove?  
S

When starting the Forecast to Inventory app, I initially tried to build it on top of my existing Track to Inventory architecture. However, the structure became overly complex, and at the same time Shopify’s official recommendation shifted from Remix to React.

A

Rather than forcing the old foundation to fit the new requirements, I decided to discard the architecture and redesign it from scratch. I separated the backend responsibilities and delegated them to Motia, clarifying boundaries between frontend logic and backend services.

R

This reset allowed me to continue development with a clean, maintainable structure that aligns with Shopify’s current standards, instead of accumulating technical debt from outdated assumptions.  

Q9:Explain how you ensured privacy or security in your system architecture.  

S

When I built Track to Inventory as my first app, I had to decide carefully where Shopify APIs should be called, because exposing credentials on the client side would be a critical security risk.

A

I reviewed multiple scenarios and centralized all sensitive API calls in the backend, ensuring that authentication tokens and environment variables were never accessible from the client.

R

As a result, the app does not expose any confidential information, and the overall security level of the system is significantly higher.  

Q10:Describe an architecture decision that improved maintainability for future you.

S

When I remade Wakarumade from a web app to a native app, embedding OCR logic directly in the app caused crashes and made the architecture fragile.

A

I separated the OCR functionality into an independent repository and deployed it as a standalone backend service with a clean API boundary. This forced me to clearly define responsibilities between the mobile client and the OCR layer.

R

I was then able to test and switch between multiple OCR APIs easily, and the system became more stable, modular, and maintainable.  
